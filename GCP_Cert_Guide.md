# Official Google Cloud Certified Associate Cloud Engineer Study Guide

# Contents
[TOC]

---

# 소개
구글 클라우드 플랫폼(GCP)는 구글에서 제공하는 동일한 소프트웨어, 하드웨어, 네트워킹 인프라를 사용자에게 제공하는 퍼블릭 클라우드다. 사업, 기업, 개인은 몇 분안에 서버를 설치하고, 페타바이트의 데이터를 저장하고, GCP에 글로벌 가상 클라우드를 구현할 수 있다. GCP에는 쉽게 사용할 수 있는 콘솔, CLI 툴, 클라우드에서 리소스를 관리하기 위한 API를 포함하고 있다. 사용자는 가상머신(VM), 디스크와 같은 일반적인 리소스를 사용하거나 IoT를 위한 서비스, 머신러닝, 미디어, 다른 특정 도메인에 특화된 서비스를 선택할 수 있다.

GCP에서 어플리케이션과 서비스를 배포하고 관리하는 것은 구글이 사용자 계정을 구성하고, identities와 접근 제어를 관리하는 방법에 명확한 이해가 필요하다. 또한 다양한 서비스의 장단점을 이해해야 한다. Associate Cloud Engineer 인증은 구글 클라우드에서 인프라, 서비스, 네트워크를 배포하고 운영하는 데에 필요한 지식과 스킬을 증명한다.

이 스터디 가이드는 Google Cloud에서 동작하는 리소스들의 필요를 충족시키기위한 GCP를 자세하게 이해하는데 도움이 되도록 설계되었다. 물론 이 책은 Associate Cloud Engineer 인증 시험을 통과하는데 도움을 주지만, 벼락치기를 위한 가이드는 아니다. 당신은 시험에 통과하기 위해 필요한 것보다 더 많이 배울 것이다. 서비스 선택, 사용자 관리, 배포, 모니터링, 클라우드 기반 솔루션에서 사업 요구사항 매핑과 같이 클라우드 엔지니어가 직면하는 이슈를 해결하는 방법을 배울 것이다.

이 책의 각 챕터는 하나의 주제를 다루고, 인증 시험을 통과하기위해 알아야하는 핵심 정보를 설명하는 "Exam Essentials" 섹션을 포함한다. 그리고 복습을 도와주고, 각 챕터의 이해력을 강화하기위한 연습을 포함한다. 시험에서 볼 수도 있는 질문의 유형 감각을 얻기 위한 샘플 문제는 각 챕터의 마지막에 포함되어있다. 이 책은 또한 쉽게 이해할 수 있도록 만든 카드(flashcard)와 가이드를 통해 배우는 모든 토픽에 대한 연습 문제를 포함하고 있다.

[맨 위로](#Contents) 

## 이 책에서 다루는 것

이 책은 GCP의 제품과 서비스를 설명한다. G Suite 관리자 주제는 포함하지 않는다.

**Chapter 1 : 구글 클라우드 플랫폼 Overview**
이 챕터에서는 compute, storage, 머신러닝 상품과 같은 networking 서비스를 포함하여 GCP에서 제공하는 서비스들의 유형을 확인한다. 이 챕터에서는 또한 클라우드 컴퓨팅과 데이터 센터 혹은 on-premise 컴퓨팅의 핵심 차이에 대해 설명한다.

**Chapter 2 : 구글 클라우드 컴퓨팅 서비스** 이 챕터에서는 computing, storage, networking과 같은 인프라스트럭쳐 서비스에 대한 기초를 제공한다. ID 관리와 관련 서비스의 컨셉도 소개한다. 또한 DevOps 주제와 어플리케이션과 리소스를 배포하고 모니터링하기 위한 도구들을 소개한다.GCP는 머신러닝과 자연어 처리 서비스와 같은 특화 서비스의 리스트를 포함한다. 이 챕터에서는 특화 서비스들을 간단하게 다룬다. 이 챕터는 regions과 zones을 살펴보면서 구글 클라우드의 조직 구조를 소개한다. 이 챕터에는 패키지된 어플리케이션을 배포하기 위한 클라우드 런쳐의 논의 내용이 포함되어있다.

**Chapter 3 : 프로젝트, 서비스계정, 빌링** GCP와 작업하기 시작할 때 해야할 일 중에 하나는 계정을 세팅하는 것이다. 이 챕터에서, 조직, 폴더, 프로젝트에서 계정별 리소스를 구성하는 방법에 대해 배울 것이다. 이 구조를 생성하고 수정하는 방법을 배울 것이다. 특정 프로젝트를 위한 API 활성화 뿐만 아니라 특정 프로젝트의 접근 제어와 사용자 ID를 관리하는 방법에 대해 배울 것이다. 이 챕터는 빌링 계정을 생성하고 프로젝트에 연결하는 방법에 대해 설명한다. 또한 예산을 생성하고, 비용환리를 도와주기위한 빌링 알림을 정의하는 방법에 대해 배울 것이다. 마지막으로 이 챕터는 GCP의 모니터링 시스템중 하나로 사용되는 Stackdriver 계정을 생성하는 방법에 대해 설명한다.

**Chapter 4 : 구글 클라우드 컴퓨팅 소개** 이 챕터에서는 GCP에서 어플리케이션과 서비스가 동작하기 위해 이용할 수 있는 다양한 옵션들을 확인할 것이다. 옵션들은 리눅스나 윈도우OS에서 동작하는 VM을 제공하는 Compute Engine을 포함한다. App Engine은 개발자들이 스스로 VM을 관리해야하는 걱정없이 그들의 어플리케이션을 실행할 수 있는 Platform as a service(PaaS) 옵션이다. 다수의 어플리케이션과 서비스를 실행할 것이라면, VM을 대체할 수 있는 가벼운 컨테이너를 원할지도 모른다. 이 챕터에서는 컨테이너와 이를 관리하는 Kubernetes Engine에 대해서 배울 것이다. 또한 Cloud Storage에서 로그되는 이미지의 처리 동작과 같이 이벤트 중심의 짧은 실행 작업을 위한 Cloud Functions를 소개한다. 또한 모바일 어플리케이션의 백엔드 인프라를 제공하는 데 적합한 서비스인 Firebase에 대해서 배울 것이다.

**Chapter 5 : Compute Engine 가상 머신의 Computing** 이 챕터에서는 CPU, 메모리, 저장소 옵션, OS 이미지를 선택하는 것을 포함한 VM 설정 방법에 대해 배울 것이다. VM을 동작하기 위한 GCP 콘솔과 Cloud Shell을 사용하는 방법을 배울 것이다. 게다가 VM을 기동하거나 정지할 때 사용할 CLI와 SDK를 설치하는 방법을 확인할 것이다. 이 챕터는 또한 VM으로 네트워크 접속을 허용하는 방법에 대해 설명한다.

**Chapter 6 : 가상머신 관리** 이전 챕터에서 VM을 생성하는 방법을 배웠고, 이 챕터에서는 VM 단위와 그룹별로 관리하는 방법을 배울 것이다. GCP 콘솔을 사용하여 VM 하나의 인스턴으를 관리하는 것으로 시작할 것이다. 그리고 Cloud Shell과 CLI를 사용하여 같은 동작을 수행할 것이다. 다음으로, 하나의 단위로 관리할 수 있는 VM 집합을 생성하도록 허용한 인스턴스 그룹에 대해서 배울 것이다. 인스턴스 그룹 섹션에서 관리된/관리되지 않은 인스턴스 그룹의 차이를 배울것이다. 또한 구글에 의해서 정지될 수도 있는 저비용의 VM인 Preemptible instances를 배울 것이다. preemptible 인스턴스의 비용 절충에 대해서 배울 것이다. 마지막으로, 이 챕터는 VM 관리를 위한 가이드라인으로 마무리된다.

**Chapter 7 : Kubernetes 컴퓨팅** 이 챕터는 구글에서 관리하는 Kubernetes service인 Kubernetes Engine을 소개한다. Kubernetes는 구글에 의해서 생성되고, 오픈소스로 릴리즈된 컨테이너 오케스트레이션 플랫폼이다. 이 챕터에서는 컨테이너, 컨테이너 오케스트레이션, Kubernetes 아키텍처의 기초에 대해서 배울 것이다. Pods, Services, Volumes, Namespace와 같은 Kubernetes 오브젝트 뿐만 아니라, ReplicaSets, deployments, jobs과 같은 Kubernetes 컨트롤러의 소개를 포함한다.
다음으로, 이 챕터는 GCP 콘솔, Cloud Shell, SDK를 사용하여 Kubernetes 클러스터를 배포하는 것을 배운다. 또한 존재하는 Docker 이미지 다운로드, Dokcer 이미지 빌드, pod 생성과 같이 Pods를 배포하는 방법과 Kubernetes 클러스터에 어플리케이션을 배포하는 것에 대해 학습한다. 서버의 클러스터를 확인하는 방법에 대해 알 필요가 있다. 이 챕터에서는 구글의 어플리케이션, 서비스, 컨테이너, 인프라 모니터링 서비스인 스택드라이버를 이용하여 모니터링과 로깅을 세팅하는 방법에 대한 설명을 제공한다.

**Chapter 8 Kubernetes 클러스터 관리** 이 챕터에서는 클러스터의 상태 확인, 이미지 저장소의 컨텐츠 확인, 저장소에 저장된 이미지의 세부정보 확인, node/pod/service의 추가/수정/삭제에 대한 Kubernetes 클러스터 관리의 기초에 대해서 배울 것이다. VM 관리 챕터처럼 이 챕터에서는 3가지 관리도구(GCP 콘솔, Cloud Shell, SDK)를 이용하여 관리 동작을 수행하는 방법을 배울 것이다. 이 챕터는 Kubernetes 클러스터 관리를 위한 좋은 예시와 가이드라인에 대한 논의로 마무리한다.

**Chapter 9 App Engine 컴퓨팅** 구글 App Engine은 구글의 PaaS 서비스다. 어플리케이션, 서비스, 버전, 인스턴스와 같은 App Engine 컴포넌트에 대해 배울 것이다. 이 챕터는 또한 설정 파일을 정의하고, 어플리케이션의 dependencies를 지정하는 방법을 다룬다. 이 챕터에서는 GCP 콘솔, Cloud Shell, and SDK를 사용하여 App Engine 리소스를 확인하는 방법을 배울 것이다. 또한 분산 매개변수로 트래픽을 조정하여 워크로드를 분산하는 방법을 설명한다. 또한 App Engine의 오토 스케일링에 대해서 배울 것이다.

**Chapter 10 Cloud Functions 컴퓨팅** Cloud Functions은 이벤트 기반을 위한 서버리스 연산이다. 이 챕터에서는 Cloud Functions를 사용하여 이벤트를 수신하고, 서비스를 실행하고, 결과를 리턴하는 것을 소개한다. 다음으로 3rd party API 통합, 이벤트 기반 처리와 같은 Cloud Functions의 사용 사례를 확인할 것이다. publications, subscription 기반의 처리를 위한 구글의 Pub/Sub 서비스와 Pub/Sub과 함께 Cloud Functions을 사용하는 방법에 대해 배울 것이다. Cloud Function은 Cloud Storage에서 이벤트를 응답하는데 잘 맞는다. 이 챕터에서는 Cloud Storage 이벤트와 이 이벤트를 수신하고 응답하기 위한 Cloud Functions의 사용 방법에 대해 설명한다. Cloud functions 실행의 상세 로그와 모니터링을 위한 Stackdriver 사용 방법을 배울 것이다. 마지막으로 이 챕터는 Cloud Functions 사용과 관리를 위한 가이드라인으로 마무리한다.

**Chapter 11 클라우드에서 storage 계획** GCP의 다양한 컴퓨팅 옵션에 대해서 설명했고, 이제는 Storage로 변경할 때이다. 이 챕터는 접속, 지속 시간, 데이터 모델과 같은 storage 시스템의 특정을 설명한다. 이 챕터에서는 캐쉬, persistent storage, archival storage의 차이에 대해 배울 것이다. regional과 multi regional persistent storage와 nearline vs coldline archival storage를 사용하는 것의 비용 절감 효과에 대해서 배울 것이다. 이 챕터에는 blob storage를 위한 Cloud Storage, 관계형 저장소 옵션인 Cloud SQL과 Spanner, NoSQL 저장소를 위한 Datastore, Bigtable, BigQuery 옵션에 해당하는 다양한 GCP 저장소 옵션에 대한 상세정보를 포함한다. 이 챕터는 지속성, 이용가능성, 트랜잭션 지원, 비용, 지연, 다른 read/write 패턴을 위한 지원의 요구사항을 기반에 기반한 데이터 저장소를 선택하는 자세한 가이드라인을 포함한다.

**Chapter 12 : 구글 클라우드 플랫폼에 저장소 배포** 이 챕터에서는 GCP의 스토리지 시스템의 각각에서 데이터베이스를 생성하고, 데이터를 추가하고, 레코드를 나열하고, 데이터를 삭제하는 방법을 배울 것이다. 이 챕터는 MySQL과 PostgreSQL을 제공하는 관리형 데이터베이스 서비스인 Cloud SQL을 소개하는 것으로 시작한다. Cloud Datastore, BigQuery, Bigtable, Spanner에 데이터베이스를 생성하는 방법을 배울 것이다. 다음으로, 메시지 큐에 데이터를 저장할 수 있는 Cloud Pub/Sub을 배우고, 큰 데이터 셋을 처리하기 위한 Hadoop, Spark 클러스터 서비스과 같은 Cloud Dataproc에 대해 논한다. 다음 섹션에서는 오브젝트를 위한 Cloud Storage에 대해 배울 것이다. 이 챕터는 특정 요구사항 집합을 위한 데이터 저장소를 선택하는 방법에 대한 가이드로 마무리한다.

**Chapter 13 : 스토리지에서 데이터 불러오기** GCP에서 데이터를 얻는 방법은 다양하다. 이 챕터는 Cloud SQL, Cloud Storage, Datastore, BigQuery, BigTable, Dataproc에서 데이터를 로드하기 위해 CLI SDK를 사용하는 방법에 대해 설명한다. 또한 같은 서비스에 대해 벌크로 데이터를 적재하거나 추출하는 것을 설명한다. 다음으로, Cloud Storage로부터 데이터를 옮기고, Cloud Pub/Sub으로 데이터를 스트리밍하는 2가지 공통 데이터 로딩 패턴에 대해 배울 것이다.

**Chapter 14 : 클라우드 네트워킹: Virtual Private Clouds와 Virtual Private Networks** 이 챕터에서는 아래 내용같은 기본 네트워킹 컨셉의 소개와 함께 네트워킹을 배울 것이다.
* IP 주소
* CIDR blocks
* Network와 subnetworks
* Virtual Private Clouds (VPCs)
* Routing과 rules
* Virtual Private Network (VPNs)
* Cloud DNS
* Cloud routers
* Cloud interconnect
* External peering
네트워킹 컨셉의 핵심이 소개된 후에, VPC를 생성하는 방법에 대해 배울 것이다. 특히, VPC 정의, 방화벽 정책 지정, VPN 생성, 로드 밸런서 동작이 포함될 것이다. 로드밸런서의 다른 유형과 이를 사용하는 시기에 대해서 배울 것이다.

**Chapter 15 : 클라우드 네트워킹 : DNS, 로드 밸런싱, IP할당** 이 챕터에서는 서브넷 정의, VPN 서브넷 추가, CIDR 블럭 관리, IP 주소 확보와 같은 공통 네트워크 관리 업무에 대해서 배울 것이다. Cloud 콘솔, Cloud Shell, Cloud SDK를 사용하여 각 업무를 수행하는 방법에 대해 배울 것이다.

**Chapter 16 : Cloud Launcher와 배포 매니저로 어플리케이션 배포** 구글 클라우드 런처는 미리 설정된 stacks과 서비스의 마켓플레이스다. 이 챕터에서는 Cloud Launcher를 소개하고, 몇몇 어플리케이션과 현재 이용가능한 서비스를 설명한다. Cloud Launcher을 통해서 탐색하고, 어플리케이션을 배포하고, 어플리케이션을 중지하는 방법을 배울 것이다. 또한 이 챕터에서는 어플리케이션의 배포를 자동화하는 Deployment Manager 템플릿, GCP 리소스 할당을 위한 템플릿, 자동적으로 어플리케이션 설정하는 것을 논의한다.

**Chapter 17 : 접근과 보안 설정** 이 챕터에서는 ID 관리를 소개한다. 특히, ID, roles, 권한 할당과 제거를 배울 것이다. 또한 이 챕터에서는 서비스 계정을 소개하고, 계정을 생성하고, 계정에 VM을 할당하고, 프로젝트를 동작하는 방법을 소개한다. 그리고 프로젝트와 서비스를 위한 감시 로그를 확인하는 바업을 배울 것이다. 이 챕터는 접근 제어 보안 설정을 위한 가이드라인으로 마무리한다.

**Chapter 18 : 모니터링, 로딩, 비용 예측** 마지막 챕터에서는 Stackdriver 알림, 로그, 분산 추적, 어플리케이션 디버깅을 논한다. GCP 서비스에 해당하는 것들은 더 효과적이고, 기능적이고, 신뢰적인 서비스로 설계되었다. 이 챕터는 GCP에서 리소스의 비용을 예측하기위해 도움이 되는 비용 계산의 리뷰로 마무리한다.

[맨 위로](#Contents) 

## 시험 과목

Associate Cloud Engineer 인증은 GCP에 기업 어플리케이션과 인프라를 생성하고, 배포하고, 관리하는 사람을 위해 설계되었다. Associate Cloud Engineer는 Cloud Console, Cloud Shell, Cloud SDK와 동작하기 적합하다. 또한 GCP의 한 부분으로 제공되는 제품과 적합한 사용사례를 이해한다.
이 시험은 아래 내용에 대해서 당신의 지식을 테스트한다.
* 하나이상의 GCP 서비스를 사용하여 클라우드 솔루션을 기획하는 것
* 조직을 위한 클라우드 환경을 생성하는 것
* 어플리케이션과 인프라를 배포하는 것
* 클라우드 솔루션의 이용가능성을 보증하기위해 모니터링과 로깅을 사용하는 것
* ID 관리, 접근 제어, 다른 보안 감지를 세팅하는 것

### 과목 map

아래는 [https://cloud.google.com/certification/guides/cloud-engineer](https://cloud.google.com/certification/guides/cloud-engineer) 에서 구글이 정의한 과목이 명시한다.

**Section 1 : 클라우드 솔루션 환경 세팅**

**1.1 클라우드 프로젝트와 계정 세팅**
* 프로젝트 생성
* 프로젝트 내에서 사전 정의된 IAM(Identity and Access Management)룰을 사용자에게 할당하는 것
* G suite ID에 유저를 연결하는 것
* 프로젝트 내에서 API를 활성화하는 것
* 하나 이상의 Stackdriver 계정을 프로비저닝 하는 것
  
**1.2 과금 설정 관리**
* 하나이상의 과금 계정을 생성하는 것
* 빌링 계정을 프로젝트에 연결하는 것
* 과금 예산과 알림을 설정하는 것
* 일/월 단위 비용을 측청하기위한 과금 내보내기 설정하는 것
  
**1.3 command-line interface(CLI), 특히 Cloud SDK를 설치하고 설정**

**Section 2 : 클라우드 솔루션을 기획하고 설정**

**2.1 비용 계산기를 사용하여 GCP 제품 사용을 기획하고 측정하는 것**

**2.2 컴퓨트 자원을 기획하고 설정하는 것**
* 주어진 워크로드를 위해 적합한 compute를 선택하는 것(ex. Compute Engine, Kubernetes Engine, App Engine)
* 미리 선점된 VM과 커스텀 머신을 사용하는 것
  
**2.3 데이터 스토리지 옵션을 기획하고 설정**
* 제품 선택(ex. Cloud SQL, BigQuery, Cloud Spanner, Cloud Bigtable)
* 스토리지 옵션 선택(ex. Reginal, Multiregional, Nearline, Coldline)
  
**2.4 네트워크 리소스를 기획하고 설정**
* 로드밸런싱 옵션을 구별하는 것
* 이용가능성을 위해 네트워크에서 리소스 위치를 지정하는 것
* Cloud DNS 설정하는 것

**Section 3 : 클라우스 솔루션을 배포하고 구현**

**3.1 Compute Engine 리소스를 배포하고 구현하는 것**
* Cloud Console과 Cloud SDK(gcloud)를 사용하여 compute instance를 실행하는 것(ex. assign disk, availability policy, SSH keys)
* 인스턴스 템플릿을 사용하여 오토스케일 관리 인스턴스 그룹을 생성하는 것
* 인스턴스를 위한 커스텀 SSH 키를 생성하고 업로드하는 것
* Stackdriver 모니터링과 로깅을 위한 VM을 설정하는 것
* compute 할당량 평가와 증설 요청
* 모니터링과 로깅을 위한 Stackdriver 에이전트를 설치하는 것

**3.2 Kubernetes Engine 리소스를 배포하고 구현**
* Kubernetes Enging 클러스터 배포하기
* pod를 사용하여 Kubernetes Engine에 container 어플리케이션을 배포하는 것
* Kubernetes Engine 어플리케이션 모니터링과 로깅 설정하는 것
  
**3.3 App Engine과 Cloud Functions 리소스를 배포하고 구현**
* App Engine에 어플리케이션 배포하는 것(ex. scaling configuration, versions, traffic splitting)
* Google Cloud 이벤트를 받는 Cloud Functions 배포하는 것(ex. Cloud Pub/Sub 이벤트, Cloud Storage object 변경 알림 이벤트)
  
**3.4 데이터 솔루션을 배포하고 구현**
* 데이터 시스템 제품 초기화(ex. Cloud SQL, Cloud Datastore, BigQuery, Cloud Spanner, Cloud Pub/Sub, Cloud Bigtable, Cloud Dataproc, Cloud Storage)
* 데이터 로딩(ex. command-line upload, API transfer, import/export, Cloud Storage에서 데이터 로드, Cloud Pub/Sub에서 데이터 스트리밍)
  
**3.5 네트워킹 리소스를 배포하고 구현**
* 서브넷과 함께 VPC 생성(ex. custom-mode VPC, shared VPC)
* 커스텀 네트워크 설정과 함께 Compute Engine 인스턴스 실행(ex. internal-only IP address, Google private access, static external, private IP address, network tags)
* VPC를 위한 ingress, egress 방화벽 정책 생성(ex. IP subnet, tags, service accounts)
* Cloud VPN을 사용하여 Google VPC와 외부 네트워크간 VPN 생성
* 어플리케이션으로 들어오는 네트워크 트래픽을 분산하기위한 로드밸런서 생성(ex. global HTTP(S) load balancer, global SSL proxy load balancer, global TCP proxy load balancer, regional network load balancer, regional internal load balancer)
  
**3.6 Cloud Launcher를 사용하여 솔루션 배포**
* Cloud Launcher 카탈로그를 탐색하고 솔루션 정보를 확인
* Cloud Launcher 마켓플레이스 솔루션 배포
  
**3.7 Deployment Manager를 사용하여 어플리케이션 배포**
* 어플리케이션의 배포를 자동화하는 Deployment Manager 템플릿 배포
* GCP 리소스를 할당하고 어플리케이션을 자동적으로 설정하는 Deployment Manager 템플릿 배포

**Section 4 : 클라우드 솔루션의 성동적인 운영 보증**

**4.1 Compute Engine 리소스 관리**
* 싱글 VM 인스턴스 관리(ex. start, stop, edit configuration, or delete an instance)
* 인스턴스 SSH/RDP
* 새로운 인스턴스에 GPU 추가, CUDA 라이브러리 설치
* 현재 동작하고있는 VM 인벤토리 조회(instance IDs, 상세정보)
* 스냅샷 작업(ex. VM의 스냅샷 생성, 조회, 삭제)
* 이미지 작업(ex. VM 이미지 생성, 조회, 삭제)
* 인스턴스 그룹 작업(ex. 오토스케일링 파라미터 세팅, 인스턴스 템플릿 할당, 인스턴스 템플릿 생성, 인스턴스 그룹 제거)
* 관리 인터페이스 작업(ex. Cloud Console, Cloud Shell, Cloud SDK)
  
**4.2 Kubernetes Engine 리소스 관리**
* 현재 동작하고 있는 클러스터 인벤토리 조회(nodes, pods, services)
* 컨테이너 이미지 저장소 탐색, 컨테이너 이미지 상세정보 조회
* nodes 작업(ex. 추가, 수정, 제거)
* pods 작업(ex. 추가, 수정, 제거)
* services 작업(ex. 추가, 수정, 제거)
* 관리 인터페이스 작업(ex. Cloud Console, Cloud Shell, Cloud SDK)

**4.3 App Engine 리소스 관리**
* 어플리케이션 트래픽 분산 파라미터 조정
* 오토스케일하는 인스턴스를 위한 파라미터 세팅
* 관리 인터페이스 작업(ex. Cloud Cosole, Cloud Shell, Cloud SDK)

**4.4 데이터 솔루션 관리**
* 데이터 인스턴스로부터 데이터를 조회하기위한 쿼리 실행(ex. Cloud SQL, BigQuery, Cloud Spanner, Cloud Bigtable, Cloud Dataproc)
* BigQuery 쿼리의 비용 측정
* 데이터 인스턴스 백업 및 원복(ex. Cloud SQL, Cloud Datastore, Cloud Dataproc)
* Cloud Dataproc이나 BigQuery에서 작업 상태 확인
* Cloud Storage 버킷간 오브젝트 이동
* 스토리지 클래스간 Cloud Storage 버킷 변환
* Cloud Storage 버킷을 위한 오브젝트 lifecyle 관리 정책 세팅
* 관리 인터페이스 작업(ex. Cloud Console, Cloud Shell, Cloud SDK)

**4.5 네트워킹 리소스 관리**
* 존재하는 VPC에 서브넷 추가
* 많은 IP 주소를 갖기 위한 CIDR 단위 서브넷 확장
* 정적 외부/내부 IP주소 확보
* 관리 인터페이스 작업(ex. Cloud Console, Cloud Shel, Cloud SDK)

**4.6 모니터링과 로깅**
* 리소스 메트릭스 기반의 Stackdriver 알림 생성
* Stackdriver 커스텀 메트릭스 생성
* 외부 시스템으로 로그를 내보내기위한 로그 싱크 설정(ex. on-premise 혹은 BigQuery)
* Stackdriver에서 로그 조회, 필터
* Stackdriver에서 특정 로그 메시지 상세정보 조회
* 어플리케이션 이슈를 연구하기위한 클라우드 진단 사용(ex. Cloud Trace 데이터 조회, 시간별 어플리케이션 포인트를 조회하기 위한 Cloud Debug 사용)
* GCP 상태 조회
* 관리 인터페이스 작업(ex. Cloud Console, Cloud Shell, Cloud SDK)

**Section 5: 접근 및 보안 설정**

**5.1 Identity와 접근 관리**
* 계정 IAM 할당 조회
* 계정이나 Google 그룹에 IAM 정책 할당
* 커스텀 IAM 정책 정의

**5.2 service account 관리**
* 한정된 범위로 서비스 계정 관리
* VM 인스턴스에 서비스 계정 할당
* 다른 프로젝트에서 서비스 계정 접근 권한 부여

**5.3 프로젝트와 관리 서비스를 위한 감시로그 조회**
**클라우드 컴퓨팅 컴포넌트**
* Compute 리소스
* 스토리지
* 네트워킹
* 특별한 서비스

**Cloud Computing과 Data Center Computing의 차이**
* 리소스 소유 대신 임대
* 사용량에 따라 비용 지불
* 탄력적인 리소스 할당
* 특별한 서비스

# Chapter 1 구글 클라우드 플랫폼 Overview

**이 챕터는 Google Associate Cloud Engineer 인증 시험에서 아래 과목을 다룬다.**

*1.0 클라우드 솔루션 환경 세팅*

구글클라우드 플랫폼(GCP)은 구글이 소유하고 있는 제품에서 사용되는 기술의 일부를 제공하는 퍼블릭 클라우드 서비스이다. 이 챕터에서는 GCP의 가장 중요한 컴포넌트에 대해 설명하고, 온프레미스 데이터센터 기반의 컴퓨팅과 어떻게 다른지 논한다.

## 클라우드 서비스의 유형

구글, 아마존, 마이크로소프트와 같은 퍼블릭 클라우드 제공업체는 비즈니스 서비스와 어플리케이션의 넓은 범위에서 실행되는 컴퓨팅, 스토리지, 네트워킹, 다른 인프라스트럭쳐를 배포하기위한 서비스를 제공한다. 몇몇 클라우드 사용자는 클라우드에서 시작하는 신생 업체이다. 그들은 보유하고있는 하드웨어와 소프트웨어가 없다. 다른 클라우드 고객은 다수의 데이터센터를 보유하고있는 기업이고, 그들의 데이터 센터를 보완하기위해 퍼블릭 클라우드를 사용한다. 이 다른 종류의 사용자는 다른 요구사항을 갖고 있다.

클라우드에서 시작하는 업체는 보유하고 있는 인프라에 대한 고려없이 그들의 어플리케이션와 구조적 니즈에 가장 알맞는 서비스를 선택할 수 있다. 예를 들면, 스타트업은 모든 인증과 권한 부여 니즈를 위한 GCP의 IAM(Identity and Access Management) 서비스를 사용할 수 있다. ID 관리를 위한 마이크로소프트 Active Directory 솔루션에 이미 투자한 업체는 클라우드의 ID 관리 시스템과 단독으로 작업하는 대신 클라우드 시스템을 활용할 수도 있다. 이것은 두 시스템을 통합하고 동기화를 유기하기위한 추가적인 작업으로 이끌 수 있다.

인프라를 보유하고 있는 기업들을 위해 고려해야하는 다른 영역은 온프레미스 리소스와 퍼블릭 클라우드 리소스간 보연 네트워크를 구축과 유지하는 것이다. 온프레미스 시스템과 퍼블릭 클라우드간에 높은 볼륨의 네트워크 트래픽이 있다면, 기업에서는 데이터센터와 퍼블릭 클라우드 제공업체의 시설간 전용 네트워크를 투자할 필요가 있다. 트래픽의 양이 시설들 간 전용 연결 비용에 비해 충분하지 않다면, 업체는 공인 인터넷 위에서 동작하는 virtual private network를 사용할 수 있다. 이것은 클라우드만 사용하는 업체에게는 할 필요가 없는 추가적인 네트워크 설계와 관리가 필요하다.

퍼블릭 클라우드 제공 업체는 4가지 넓은 카테고리의 서비스를 제공한다.
* 컴퓨트 리소스
* 스토리지
* 네트워킹
* 머신러닝 서비스와 같은 특별한 서비스들

클라우드 고객들은 전형적으로 위 카테고리중 하나 이상의 서비스를 사용한다.

### Compute Resources

컴퓨팅 리소스는 퍼블릭 클라우드에서 다양한 형태로 존재한다.

#### 가상머신

가상머신은 컴퓨팅 리소스의 기본적인 단위이고 클라우드를 경험하는데 가장 좋은 시작 포인트이다. 클라우드 제공업체에 계정을 생성하고 빌링 정보를 제공한 후에, VM을 생성하는 포털이나 커맨드라인 도구를 사용할 수 있다. 구글 클라우드 플랫폼은 다양한 수의 vCPU와 다양한 메모리가 미리 지정된 다양한 VM을 제공한다. 그리고 미리 지정된 VM이 필요하지 않는다면 커스텀으로 설정해서 생성할 수 있다.

VM을 생성하면, 로그인하여서 원하는대로 관리할 수 있다. VM에 완전한 접근권한을 갖고 있어서 파일 시스템을 설정하고, 스토리지를 설정하고, OS를 설치하고, 추가적인 패키지를 설치할 수 있다. VM에서 무엇을 실행할 지, 누구를 접속하게 할 지, 언제 VM을 종료할 것인지 결정할 수 있다. 본인이 관리하는 VM은 관리자 권한을 갖는 서버를 본인의 사무일에 둔 것과 같다. 

물론 다른 운영체제와 어플리케이션을 실행하는 다수의 VM을 생성할 수 있다. 또한 GCP는 하나의 접근 포인트를 백엔드로 분산하는 로드밸런서와 같은 서비스를 제공한다. 이것은 특히 당신의 어플리케이션을 위해 HA(high availability)가 필요할 때 유용하다. 클러스터에서 VM 중 하나에 에러가 발생하면, 워크로드는 클러스터의 다른 VM으로 분산될 수 있다. 오토스케일러는 워크로드를 기반으로 클러스터의 VM을 추가하거나 제거할 수 있다. 이것을 오토 스케일링이라고 한다. 이것은 필요보다 많은 VM이 동작하지 않기 위해 비용을 제어하고, 워크로드가 증가할 때 충분한 컴퓨팅 용량을 사용할 수 있도록 도와준다.

#### 관리형 Kubernetes 클러스터

구글 클라우드 플랫폼은 서버의 클러스터를 생성하고 관리하는데 필요한 모든 도구를 제공한다. 많은 클라우드 사용자는 그들의 어플리케이션에 초점을 두고있고, 서버가 기동하고 동작하는 클러스터를 유지하는데 필요한 작업을 하지 않는다. 이 사용자들에게 관리형 클러스터는 좋은 옵션이다.

관리형 클러스터는 컨테이너를 활용한다. 컨테이너는 같은 서버에서 하나의 컨테이너에서 동작하는 프로세스가 다른 컨테이너에서 동작하는 프로세스로부터 독립되는 가벼운 VM과 같다. 관리형 클러스터에서 실행하기 원하는 서버의 수와 여기서 동작해야하는 컨테이너를 지정할 수 있다. 또한, 동작하는 컨테이너의 수에 최적화된 오토스케일링 파라미터를 지정할 수 있다.

관리형 클러스터에서 컨테이너의 상테를 모니터링한다. 컨테이너가 에러로 인해 종료되면 클러스터 관리 소프트웨어는 이를 감지하고 다른 컨테이너를 실행한다.

컨테이너는 당신의 환경에서 다수의 마이크로 서비스가 요구되는 어플리케이션을 실행할 때 좋은 옵션이다. 서비스는 컨테이너를 통해 배포되고, 클러스터 관리 서비스는 모니터링, 네트워킹, 몇몇 보안 관리 업무를 다룬다. 

#### 서버리스 컴퓨팅

VM과 관리형 Kubernetes 클러스터는 모두 컴퓨팅 리소스를 설정하고 관리하기 위한 노력이 필요하다. 서버리스 컴퓨팅은 개발자와 어플리케이션 관리자에게 VM이나 Kubernetes 클러스터를 세팅할 필요없이 컴퓨팅 환경에서 그들의 코드를 동작하는 것을 허용한다는 접근이다. 

구글 클라우드 플랫폼에선 2가지 서버리스 컴퓨팅 옵션이 있다. App Engine과 Cloud Functions. App Engine은 웹사이트 백엔드, POS 시스템, 고객 비즈니스 어플리케이션과 같이 장시간동안 실행되는 어플리케이션과 컨테이너를 위해 사용된다. Cloud Functions은 파일 업로딩이나 메시지 큐에 미시지가 추가되는 것과 같은 이벤트를 응답하기위한 코드를 실행하는 플랫폼이다. 이 서버리스 옵션은 함수로 짜여진 짧은 프로세스를 실행하거나 VM, 클러스터, App Engine에서 장시간 실행되는 어플리케이션을 호출하여 이벤트를 응답해야 할 때 잘 동작한다.

### 스토리지

퍼블릭 클라우드는 넓은 범위의 어플리케이션 요구사항에 유용한 몇몇 유형의 스토리지 서비스를 제공한다.
* Object storage
* File storage
* Block storage
* Caches

클라우드 서비스의 기업 고객은 이런 서비스들의 조합을 자주 사용할 것이다.

#### Object Storage

오브젝트 스토리지는 오브젝트나 블롭(blobs) 단위의 스토리지 사용을 관리하는 시스템이다. 보통 오브젝트는 파일이지만, 기존 파일 시스템에서 저장되지 않는다. 오브젝트는 버킷에 그룹화된다. 각 오브젝트는 개별로 주소가 지정될 수 있고, 보통 URL로 지정된다.

오브젝트 스토리지는 서버의 디스크나 SSD 사이즈에 의해 제한되지 않는다. 오브젝트는 디스크의 사용 용량에 대한 걱정없이 업로드할 수 있다. 가용성과 내구성을 향상시키기 위해서 다수의 오브젝트 복사본이 저장된다. 몇몇 케이스에서 오브젝트의 복사본은 가용성을 보장하기 위해서 다른 regions에 저장될 수도 있다.

오브젝트 스토리지의 다른 장점은 서버리스다. 스토리지를 위해서 VM이 필요하지 않다. Cloud Storage라고 불리는 GCP의 오브젝트 스토리지는 GCP에서 동작하는 서버뿐만 아니라 인터넷에 접속한 다른 디바이스에서 접근할 수 있다.

접근 제어는 오브젝트 단위로 적용할 수 있다. Cloud storae 사용자에게 오브젝트에 접근하고 업데이트할 수 있도록 허용한다.

#### File Storage

파일 스토리지는 파일을 위한 계층구조의 스토리지 시스템이다. 파일 시스템 스토리지는 네트워크 공유 파일 시스템을 제공한다. GCP는 Cloud Filestore라고 불리는 네트워크파일시스템(NFS)기반의 파일 스토리지 서비스를 갖고있다. 

파일 스토리지는 파일 엑세스 같은 OS가 필요한 어플리케이션에 적합하다. 파일 스토리지 시스템은 파일 시스템을 특정 VM에서 분리한다. 파일시스템, 디렉토리, 파일은 해당 파일에 접근할 수 있는 VM이나 어플리케이션과 독립적으로 존재한다.

#### Block Storage

블록 스토리지는 *block* 이라고 불리는 고정된 크기의 데이터 구조를 사용하여 데이터를 구성한다. 블록 스토리지는 일반적으로 VM에 연결된 임시 및 영구 디스크에 사용된다. 블록 스토리시 시스템을 사용하면, 블록 스토리지 위에 파일시스템을 설치하거나 블록에 직접 접근하는 어플리케이션을 실행할 수 있다. 

리눅스 파일 시스템에서는 4KB가 일반적인 블록 사이즈이다. 관계형 데이터베이스는 종종 직접 블록을 쓰지만, 8KB 이상의 큰 사이즈를 종종 사용한다. 

블록 스토리지는 GCP에서 VM에 연결된 디스크에서 이용할 수 있다. 블록 스토리지는 임시적이거나 영구적일 수 있다. 영구 디스크(persistent disk)는 가상 서버에서 연결이 끊어지거나 서버가 죽어도 저장된 데이터를 유지한다. 임시 디스크(Ephemeral disk)는 VM이 동작하는 동안 데이터를 저장한다. 임시 디스크는 OS파일과 다른 파일들, VM이 멈추면 삭제되는 데이터를 저장한다. 영구 디스크는 VM과 독립적인 블록 스토리지 장치에 저장하기를 원할 때 사용된다. 이러한 디스크는 VM 라이프사이클과 독립적으로 사용히고, OS 및 파일시스템 레벨의 빠르게 접근하기를 원하는 데이터를 가질 때 좋은 옵션이다.

오브젝트 스토리지는 VM 라이프사이틀과 독립적으로 데이터를 저장하지만, OS나 파일시스템 접근를 지원하지 않는다.(오브젝트에 접근하는 HTTP와 같은 하이레벨 프로토콜을 사용해야한다.) 오브젝트 스토리지의 데이터를 조회하는 것은 블록 스토리지의 데이터를 조회하는것보다 오래걸린다. 어플리케이션의 필요에따라 오브젝트 스토리지와 블록 스토리지의 결합이 필요할 수 있다. 오브젝트 스토리지는 필요할 때 영구 디스크에 복사된 대용량의 데이터를 저장할 수 있다. 이 결합은 필요할 때 OS와 파일시스템 접근과 함께 대용량 스토리지의 이점을 제공한다.

#### Caches

캐쉬는 데이터를 빠르게 접근하는 인메모리 데이터 저장소이다. 데이터를 조회하는 데 걸리는 시간은 *latency*라고 부른다. 인메모리 저장소의 latency는 1 밀리초 미만으로 설계되었다. 비교를 위해서 아래 latency 참고:
* 기본 메모리 참조를 만드느데 100나노초 혹은 0.1마이크로초
* SSD의 4KB 임의 데이터를 읽는 것은 150 마이크로초
* 메모리의 1MB 데이터를 순차적으로 읽는 것은 250 마이크로초
* SSD의 1MB 데이터를 순차적으로 읽는 것은 1,000 마이크로초 혹은 1 밀리초
* 디스크의 1MB 데이터를 순차적으로 읽는 것은 20,000 마이크로초 혹은 20 밀리초

단위 변환을 위한 참조:
* 1,000 나노초 = 1 마이크로초
* 1,000 마이크로초 = 1 밀리초
* 1,000 밀리초 = 1 초

유용한 데이터 타이밍은 Jonas Boner의 "Latency Numbers Every Programmer Should Know"에서 확인할 수 있다. [https://gist.github.com/jboner/2841832](https://gist.github.com/jboner/2841832)

1MB 데이터를 읽는 예로 보자. 인메미로 캐쉬에 저장된 데이터를 갖고있다면, 이 데이터를 조회하는데 250 마이크로초 혹은 0.25 밀리초가 걸린다. 같은 데이터가 SSD에 저장되면, 조회하는데 시간이 1밀리초로 4배가 걸린다. 같은 데이터가 하드디스크에 저장되면, 20 밀리초가 예측되고 이는 인메모리 캐쉬보다 80배이다.

캐쉬는 어플리케이션에서 최소한의 지연으로 데이터를 읽을 필요가 있을 때 꽤 유용하다. 물론, 빠른 조회 시간을 누가 안 좋아하나? 왜 항상 데이터를 캐쉬에 저장하지 않을까? 3가지 이유가 있다.
* 메모리는 SSD나 HDD 스토리지보다 비싸다. 대부분의 경우 SSD 또는 HDD의 영구 블록 스토리지만큼 인메모리 스토리지를 보유하는 것은 실용적이지 않다.
* 캐쉬는 휘발성이다. 전원이 끊어지거나 OS가 재부팅될 때 캐쉬에 저장된 데이터를 잃는다. 빠른 접근을 위해서 캐쉬에 데이터를 저장할 수 있지만, 데이터를 유지하는 유일한 저장소로 사용되어서는 안 된다. "진정한 시스템" 혹은 항상 최신, 가장 정확한 버전의 데이터를 저장한 데이터 저장소를 유지하기 위해서는 어떠한 형태의 영구 디스크를 사용해야 한다.
* 캐쉬는 실제 시스템과 동기화되지 않을 수 있다. 실제 시스템에 업로드 되었지만, 새로운 데이터가 캐쉬에 쓰여지지 않는 경우가 생길 수 있다. 이 현상이 발생했을 때, 캐쉬에 의존하는 어플리케이션에서는 캐쉬에 있는 데이터가 적절하지 않다는 사실을 감지하는 것은 어려울 수 있다. 캐쉬를 사용하기로 결정을 했다면 캐쉬와 실제 시스템간 지속성을 위한 요구사항을 충족하는 캐쉬 업데이트 전략을 설계해야 한다. 이 것은 Phil Karlton의 잘 알려진 명언인 "There are only two hard thins in computer science: cache invalidation and naming thins." ([https://martinfowler.com/bliki/TwoHardThings.html](https://martinfowler.com/bliki/TwoHardThings.html))처럼 어려운 설계 문제이다.

> **실제 시나리오** <br>
> 데이터베이스 쿼리 응답시간 개선하기
>> 사용자는 빠르게 응답하는 웹 어플리케이션을 기대합니다. 페이지가 로드하는데 2~3초이상 소요된다면, UX는 고통일 수 있다. 고객 ID에 계정 정보를 찾는 것과 같이 데이터베이스 쿼리의 결과를 사용하는 페이지의 컨텐츠를 생성하는 데 일반적이다. 데이터베이스를 쿼리할 때, 데이터베이스 엔진은 보통 디스크에서 데이터를 찾을 것이다. 많은 유저가 데이베이스로 쿼리를 할수록 많은 쿼리가 발생한다. 데이터베이스는 응답이 필요하지만, 다른 쿼리로 인해 바쁘기 때문에 처리하지 못하는 쿼리에 대한 큐를 갖고 있다. 이 것은 웹 어플리케이션이 쿼리의 결과가 리턴되기를 기다려야하기 때문에, 응답 시간이 지연되는 원인일 수 있다.
>> 
>> 지연시간을 줄기는 한 가지 방법은 데이터를 읽는데 필요한 시간을 줄이는 것이다. 몇몇 경우에서, 하드디스크를 더 빠른 SSD로 대체하는 것이 도움이 된다. 그러나 쿼리의 양이 SSD에서도 큐에서 오래 걸린다면, 캐쉬를 사용하는 것이 또 다른 옵션이다.
>> 
>> 쿼리 결과를 가져올 때, 캐쉬에 저장된다. 정보가 필요할 때, 데이터베이스 대진 캐쉬에서 가져온다. 이 것은 데이터를 디스크보다 빠르게 메모리에서 가져오기 때문에 시간을 줄일 수 있다. 또한 데이터베이스 쿼리의 양을 줄이므로 캐쉬에서 데이터를 조회할 수 없는 쿼리는 처리되기 전에 쿼리 큐에서 오래 기다릴 필요가 없다.

### 네트워킹

클라우드에서 동작할 때, 클라우드 리소스와 온프레미스 시스템간 네트워킹을 작업할 필요가 있을 것이다.

클라우드 환경에서 동작하는 다수의 VM을 갖고 있을 때, 몇몇 포인트의 IP 주소를 관리할 필요가 있을 것이다. 사용자 환경에서 각 네트워크 접근 장치나 서비스는 IP주소가 필요할 것이다. 사실, GCP 내 장치는 내부와 외부 주소를 갖을 수 있다. 내부 주소는 오직 GCP 내부 네트워크에서 서비스를 접속할 수 있다. GCP 내부 네트워크는 Virtual Private Cloud(VPC)로 정의된다. 외부 주소는 인터넷을 통해서 접속할 수 있다.

외부 IP 주소는 정적 주소나 임시 주소가 될 수 있다. 정적 주소는 장시간동안 장치에 할당된다. 임시 외부 IP주소는 VM에 붙여지고, VM이 멈췄을 때 개방된다. 

IP주소를 지정하는것 외에도, VPC의 서브네트워크와 VM들로 접근을 제어하는 방화벽 정책을 정의할 필요가 있을 것이다. 예를 들어, 오직 어플리케이션 서버만 데이터베이스롤 쿼리할 수 있도록 접근을 제한하려는 데이터베이스 서버가 있을 수 있다. 방화벽 정책은 어플리케이션의 IP주소나 어플리케이션 클러스터의 앞에 있는 로드밸런서로의 인바운드와 아웃바운드 트랙픽을 제한하도록 설정할 수 있다. 

온프레미스 데이터 센터와 VPM 간에 데이터와 네트워크 접근을 공유할 필요가 있을 수 있다. 별개의 네트워크를 연결하기 위한 일반적인 용어인 *peering*의 여러 유형중 하나를 사용하여 수행할 수 있다.

### 특별한 서비스

대부분의 퍼블릭 클라우드 제공업체는 어플리케이션의 블록이나 데이터를 처리하기 위한 절차의 한 부분에서 사용될 수 있는 특별한 서비스를 제공한다.

특별한 서비스의 공통적인 특성은 아래와 같다.
* 서버리스이다.; 서버나 클러스터를 구성할 필요가 없다.
* 텍스트를 번역하거나 이미지를 분석하는 특정 함수를 제공한다.
* 서비스의 기능을 접근하는 API(Application Programming Interface)를 제공한다.
* 다른 클라우드 서비스와 마찬가지로 서비스에서 사용하는 만큼 비용이 청구된다.

GCP의 특별한 서비스 중 일부는 아래와 같다.
* 머신러닝 서비스, AutoML
* 텍스트를 분석하기위한 서비스인 Cloud Natural Language
* 이미지 분석을 위한 Cloud Vision
* 시간 단위 데이터에 대한 상관관계를 계산하는 서비스인 Cloud Interface API

특별한 서비스는 고급 컴퓨팅 기능을 캡슐화하여 자연언어 처리와 머신러닝과 같은 도메인을 전문가가 아닌 개발자가 접근할 수 있도록 한다. GCP에 더 많은 특별한 서비스가 추가될 것으로 예상된다.

### 클라우드 컴퓨팅 vs 데이터센터 컴퓨팅

클라우드에서 동작하는 VM이 데이터센터에서 동작하는 VM과 차이가 없어보여도, 클라우드에서 운영하는 IT환경과 온프레미스나 데이터센터간에 상당한 차이가 있다.

#### 리소스 소유 대신 대여

기업의 데이터 센터는 서버, 디스크, 네트워크 장치로 가득차있다. 이 장치는 회사에 소유되거나 장기간동안 임대되고, 이 모델은 장치를 구매하거나 장기간 임대하기 위해서 상당한 양의 돈을 회사에서 소비한다. 이 방법은 기업에서 장기간 필요한 서버와 다른 장치의 양을 정확하게 예측하고, 지속적으로 활용할 수 있을 때 적합하다.

이 모델은 기업이 평균 워크로드보다 상당히 높은 용량을 계획해야할 때 제대로 동작하지 않는다. 예를 들어, 유통업체가 20개 서버의 클러스터가 필요한 평균 로드를 받고 있지만, 연휴기간동은 워크로드는 80개의 서버가 필요한 포인트까지 증가한다. 회사는 80개의 서버를 구매하고, 60개의 서버를 1년의 대부분을 Idle 상태로 두어 최대 용량을 수용할 수 있는 자원으로 확보한다. 그 대신에 더 적은 서버를 구매하거나 임대할 수 있고, 컴퓨트 리소스가 수요를 견딜 수 없을 때 일어나는 기업의 손실을 발생한다. 둘 다 매력적인 옵션을 아니다.

퍼블릭 클라우드는 컴퓨트 용량의 단기간 대여의 대안을 제공한다. 예를 들어, 유통업체가 피크 기간동안 온프레미스 서버 이외에도 클라우드에서 VM을 동작했다. 이 것은 유통업체는 필요하지 않을 때 비용 지불을 하지 않고, 필요할 때 서버에 접근할 수 있따.

클라우드에서 동작 중인 서버의 단위 비용은 데이터 센터에서 동작 중인 동등한 서버보다 높을 수도 있다. 하지만, 온 프레미스의 전체 비용과 클라우드에서 단기간 서버의 조합은 최대 용량을 위한 구매나 임대하는 것과 리소스를 유휴상태로 유지하는 비용보다 상당히 적을 수 있다.

#### 종량제 모델

클라우드 컴퓨팅의 단기간 임대 모델와 관련있는 것은 종량제 모델이다. 클라우드에서 가상 서버를 동작할 때, 전형적으로 10분과 같이 최소 기간동안과 이 후에 사용된 시간만큼 비용을 지불할 것이다. 분당 단위 비용은 서버의 특성에 따라 다르다. 많은 CPU와 메모리를 갖는 서버는 적은 CPU와 메모리를 갖는 서버보다 많은 비용이 발생한다.

클라우드 엔지니어는 클라우드 제공업체의 비용 모델을 이해하는 것이 중요하다. 사용내역에 대해서 모니터링하지 않는다면 서버와 스토리지에 대해 많은 비용청구서를 받기 쉽다. 사실, 몇몇 클라우드 사용자들은 클라우드에서 동작하는 어플리케이션이 온프레미스에서 동작하는 것보다 더 비쌀수 있다는 것을 알고 있다.

#### 탄력적인 리소스 할당

온프레미스와 퍼블릭 클라우드 컴퓨팅 간 또 다른 차별화 키는 짧은 알림으로 컴퓨트와 스토리지 자원을 추가하고 제거할 수 있는 능력이다. 클라우드에서 몇분만에 20개의 서버를 동작할 수 있다. 온프레미스 데이터센터에서는 몇 일이 걸리거나 추가적인 하드웨어를 할당받는다면 몇주가 걸릴 수 있다. 

클라우드 제공업체는 광범위한 컴퓨트, 스토리지, 네트워크 리소스를 갖는 데이터센터를 설계한다. 제공업체는 고객들에게 효과적인 리소스 효과적으로 임대하여 투자를 최적화한다. 고객 사용 패턴에 대한 충분한 데이터로 고객의 요구를 충족시키기 필요한 용량을 예측할 수 있다. 제공업체는 많은 고객을 가지고 있기 때문에, 한 고객의 수요 변화는 리소스의 전체적인 사용에 거의 영향을 미치지 않는다.

광범위한 리소스와 고객간에 따르게 리소스를 이동시키는 능력을 통해 퍼블릭 클라우드 제공업체는 작은 데이터센터에서 할 수 있는 것보다 더 효과적으로 탄력적인 리소스 할당을 제공할 수 있다.

#### 특별한 서비스

특별한 서비스는 널리 알려지지 않았다. 많은 개발자들은 UI를 개발하거나 데이터베이스를 쿼라히는 방법에 대해 이해하지만, 자연어 처리나 머신러닝의 상세 정보를 이해하는 사람은 거의 없다. 큰 기업은 데이터 사이언스와 머신 비전과 같은 영역에서 전문가들이 사내에서 개발할 수 있는 제정적인 자원을 가질 수도 있지만, 대부분의 다른 기업은 아니다.

특별한 서비스를 제공함으로써, 클라우드 제공업체는 더 많은 개발자들에게 고급 기능을 제공하고 있다. 많은 양의 하드웨어에 투자하는것 처럼 퍼블릭 클라우드 업체는 특별한 서비스에 투자하고, 많은 고객들에 의해서 사용되기 때문에 수익을 벌고, 비용을 회복할 수 있다.

## 시험 필수요소

**클라우드 컴퓨팅 리소스를 제공하는 다양한 방법을 이해한다.** 컴퓨팅 리소스는 개별적인 VM이나 VM 클러스터로 할당될 수 있다. 또한 Kubernetes 클러스터를 관리하는 운영적인 일부 오버헤드를 완화하는 관리형 Kubernetes 클러스터(GKE)를 사용할 수 있다. 서버리스 컴퓨팅 옵션은 사용자의 서버관리 부담을 줄여준다. 그 대신 개발자들은 클라우드 제공업체에 의해서 관리되는 컨테이너 환경이나 짧은 실행 코드를 위해 설계된 컴퓨트 플랫폼에서 그들의 코드를 실행한다. 개발자들과 DevOps 전문가들은 그들이 소요한 서버와 클러스터를 관리할 때 리소스에 대해 가장 많이 제어한다. 관리형 서비스와 서버리스 옵션은 컴퓨팅 환경에 대한 제어가 필요하지 않고, 컴퓨트 리소스를 관리하지않고 많은 가치를 얻을 때 좋은 선택이다.

**클라우드 스토리지의 다양한 형태와 사용 시기를 이해한다.** 스토리지의 4가지 분류가 있다: 오브젝트, 파일, 블록, 인메모리 캐쉬. 오브젝트 스토리지는 이미지나 데이터 셋과 같은 오브젝트 저장에 높은 신뢰성과 내구성을 위해 설계되었다. 오브젝트 스토리지는 스토리지 시스템 기반의 파일시스템보다 기능적으로 더 제한된다. 스토리지 기반의 파일 시스템은 파일을 위한 계층구조의 디렉토리 스토리지를 제공하고, 공통적인 OS와 파일 시스템 기능을 지원한다. 파일시스템 서비스는 많은 서버에 의해서 접근될 수 있는 네트워크 접근이 가능한 파일시스템을 제공한다. 블록 스토리지는 디스크에 데이터를 저장하기위해 사용된다. 파일시스템과 데이터베이스는 블록 스토리지 시스템을 사용한다. 블록 스토리지는 SSD와 HDD와 같은 영구 스토리지 장치와 사용된다. 캐쉬는 데이터 조회의 지연을 최소화하기 위해 사용되는 인메모리 데이터 저장소이다. 이는 영구 스토리지를 제공하지 않고, "진실의 시스템"으로 간주되어서는 안 된다.

**온프레미스나 클라우드에서 동작하는 IT환경 간 차이점을 이해한다.** 클라우드에서 동작하는 IT 환경은 단기간 리소스 대여, 종량제 모델, 탄력적인 리소스 할당, 특별한 서비스 사용 능력을 포함한 몇몇 장점을 갖고있다. 미들웨어 서버의 분당 비용과 같은 클라우드 리소스의 단위 비용은 온프레미스보다 클라우드가 더 높을 수도 있다. 클라우드와 온프레미스 리소스간 워크로드의 가장 효과적인 분산에 대해서 결정하기 위해 클라우드 제공업체의 비용 모델을 이해하는 것이 중요하다.

# Chapter 2 구글 클라우드 컴퓨팅 서비스

**이 챕터는 Google Associate Cloud Engineer 인증 시험에서 아래 과목을 다룬다.**

*2.2 주어진 워크로드를 위해 적절한 컴퓨트 옵션 선택을 포함하여 컴퓨트 리소스를 기획하고 설정하는 것*
*3.4 제품을 사용한 데이터 시스템을 초기화을 포함하여 데이터 솔루션을 배포하고 구현하는 것*

GPC는 다양한 컴퓨팅, 스토리지, 네트워킹 요구사항을 충족하는 거의 40개 이상의 서비스를 제공한다. 이 챕터에서는 가장 중요한 GCP 서비스의 overview를 제공하고, 이 서비스들의 중요한 사용 사례를 설명한다.

## GCP의 컴퓨팅 컴포넌트

GCP는 클라우드 컴퓨팅 고객의 광범위한 필요를 충적하기 위해 설게된 컴퓨트, 스토리지, 네트워킹 서비스를 포함한 클라우드 컴퓨팅 서비스이다. 작은 기업은 VM과 스토리지 서비스에 매력을 느낄 수 있다. 큰 기업과 다른 사이즈의 기업은 VM 클러스터의 높은 확장성, 다양한 관계형과 NoSQL 데이터베이스, 특별한 네트워킹 서비스, 고급 AI와 머신러닝 능력에 많은 흥미를 느낄수도 있다.

이 챕터는 GCP의 많은 서비스에 대한 overview를 제공한다. GCP에서 이용가능한 서비스의 범위는 계속 증가한다. 이 것을 읽는 시점에도 구글은 추가적인 서비스를 제공할지도 모른다. 서비스의 대부분은 몇 가지 핵심 분류로 그룹화될 수 있다.
* 컴퓨팅 리소스
* 스토리지 리소스
* 데이터베이스
* 네트워킹 서비스
* ID관리와 보안
* 개발 도구
* 관리 도구
* 특별 서비스

Associate Cloud Enginner 인증은 각 카테고리에 있는 서비스를 사용하는 방법과 각 카테고리의 다양한 서비스의 장단점에 익숙해야한다.

### 컴퓨팅 리소스

퍼블릭 클라우드 서비스는 넓은 컴퓨팅 서비스 옵션을 제공한다. 스펙트럼의 한쪽 끝에서, 고객들은 그들 스스로 VM을 생성하고 관리할 수 있다. 이 모델은 클라우드 사용자에게 모든 컴퓨팅 서비스의 가장 훌륭한 제어를 제공한다. 사용자들은 실행할 운영체제, 설치할 패키지, 백업할 시기, 다른 유지보수 작업을 수행을 선택할 수 있다. 이 컴퓨팅 서비스의 유형은 전형적으로 Infrastructure as a service(IaaS)로 언급된다.

다른 모델은 서버, 네트워크, 스토리지 시스템을 관리할 필요없이 어플리케이션을 실행할 런타임 환경을 제공하는 Platform as a service(PaaS)로 불린다. 

GCP의 IaaS 컴퓨팅 제품은 Compute Engine이라고 불리고, PaaS는 App Engine, CloudFunctions을 제공한다. 이외에도, 구글은 클러스터에서 컨테이너를 관리하기위한 서비스인 Kubernetes Engine을 제공한다. 이 서비스 유형은 VM의 개별 셋을 관리하는 것에 대체적으로 급격하게 유명해지고 있다.

#### Compute Engine

Compute Engine은 사용자가 VM을 생성하고, VM에 영구 스토리지를 추가하고, Cloud Storage와 같은 GCP의 다른 서비스를 사용할 수 있는 서비스이다.

VM은 물리적인 서버의 추상화이다. 이는 기본적으로 물리적인 서버를 모방하고, 개인 책상이나 데이터센터의 서버에서 좋아하는 운영체제를 실행하면 찾을 수 있었던 CPU, 메모리, 스토리지, 다른 서비스를 제공한다. VM들은 *하이퍼바이저*라고 불리는 로우레벨의 서비스에서 동작한다. GCP는 KVM 하이퍼바이스의 보안 강화 버전을 사용한다. KVM은 Kernel Virtual Machine을 의미하고 x86 하드웨어 위에서 동작하는 리눅스 시스템의 가상화를 제공한다.

하이퍼바이저는 리눅스나 윈도우 서버같은 운영체제 위에서 동작한다. 하이퍼바이저는 다른 *게스트 운영체제*라고 불리는 다양한 운영체제를 실행하는 동시에 각 운영체제의 활동을 다른 게스트 운영체제로부터 독립시킬 수 있다. 실행 중인 게스트 운영체제의 각 인스턴스는 VM 인스턴스이다. 그림 2.1은 물리적인 서버에서 실행하는 VM 인스턴스의 눈리적인 구성를 보여준다.

![2.1_logical_organization_of_VM_instances](./img/2.1_logical_organization_of_VM_instances.png)

FIGURE 2.1 하이퍼바이저 내에서 동작하는 VM 인스턴스

VM은 미리 정의된 여러 가지 사이즈가 있지만, 커스텀 구성으로 생성할 수 있다. 인스턴스를 생성할 때, 아래와 같은 여러 가지 파라미터를 지정할 수 있다. 
* 운영체제
* 영구 스토리지의 사이즈
* 머신러닝과 같이 계산 집중적인 동작을 위한 GPU 추가
* 선점형 VM 생성

마지막 옵션인 "선점형 VM 생성하기"는 일반적인 VM보다 80퍼센트 정도 적게 비용이 발생할 수도 있지만, VM이 구글에 의해서 언제든지 종료될 수 있다. 선점형 VM이 최소 24시간동안 실행될 경우 종종 종료된다.

챕터 4는 Compute Engine VM을 관리하는 상세 정보에 대해서 설명할 것이다. Compute Engine을 탐색하기 위해서는 구글 Cloud Console에 로그인하고, 왼쪽 메인 메뉴에서 Compute Engine을 선택한다.

#### Kubernetes Engine

Kubernetes Engine은 사용자가 서버의 클러스터에서 컨테이너화된 어플리케이션을 쉽게 실행할 수 있도록 설계되었다. 컨테이너는 컴퓨팅 프로세스와 리소스를 독립시키기 위해서 사용되기 때문에 VM과 자주 비교된다. 컨테이너는 컴퓨팅 프로세스를 독립시키기 위해서 VM보다 다른 방식을 사용한다.

언급되었던것 처럼, VM은 물리서버 위에 게스트 OS에서 동작한다. 물리적인 서버는 하이퍼바이저와 함께 운영체제도 실행한다. 컴퓨팅 리소스를 독립시키기위한 또다른 방식은 프로세스와 리소스를 독립시키는 호스트 운영체제의 기능을 사용하는 것이다. 이 방식은 하이퍼바이저가 필요하지 않으므로 호스트 운영체제는 독립 상태를 유지한다. 컨테이너 매니저 위에서 실행하는 추가 혹은 게스트 OS가 없다. 그 대신, 컨테이너는호스트 운영체제 기능을 사용하는 동시에 운영체제와 컨테이너 매니저는 동작 중인 컨테이너간 독립을 보장한다. 그림 2.2는 컨테이너의 논리적인 구조를 보여준다.

![2.2_logical_structure_of_containers](./img/2.2_logical_structure_of_containers.png)

FIGURE 2.2 물리 서버에서 동작하는 컨테이너

Kubernetes Engine은 사용자가 서비스를 실행할 수 있는 컴퓨트, 스토리지, 메모리 리소스를 설명할 수 있는 GCP 제품이다. Kubernetes Engine은 기본적인 리소스를 할당한다. 커맨드라인이나 GUI를 사용하면 Kubernetes 클러스터의 리소스를 추가하고 제거하기 쉽다.

게다가, Kubernetes는 클러스터에 있는 서버의 상태를 모니터링하고, 서버의 에러와 같은 문제를 자동적으로 해결한다. Kubernetes Engine은 또한 어플리케이션의 부하가 증가하면, Kubernetes Engine은 추가적인 리소스를 할당하기 위해서 오토스케일링을 지원한다.

챕터 7은 Kubernetes Engine을 기획하고 관리하기위한 상세정보에 대해 설명할 것이다. Kubernetes Engine을 탐색하기 위해서 구글 Cloud Console에 로그인하고, 왼쪽 메뉴에서 Kubernetes Engine을 선택한다.

#### App Engine

App Engine은 GCP의 컴퓨트 PaaS 상품이다. App Engine을 사용하는 개발자와 어플리케이션 관리자는 VM 구성이나 Kubernetes 클러스터 설정에 대해 관여할 필요가 없다. 그 대신, 개발자는 Java, Go, Python, Node.JS와 같은 언어로 어플리케이션을 만들고, 서버리스 어플리케이션 환경에 코드를 배포한다.

App Engine은 기본적인 컴퓨팅과 네트워크 인프라를 관리한다. VM이나 어플리케이션을 보호하는 강화된 네트워크를 설정할 필요가 없다. App Engine은 웹과 모바일 백엔드 어플리케이션에 적절하다. 

App Engine은 2가지 유형으로 이용할 수 있다: standard and flexible

standard 환경에서는 특정 언어별 샌드박스에서 어플리케이션을 실행하므로, 어플리케이션은 기본적인 서버의 운영체제뿐만 아니라 서버에서 동작하는 다른 어플리케이션으로부터 분리된다. standard 환경은 지왼되는 언어 중 하나로 만들어진 어플리케이션에 적합하고, 어플리케이션 코드와 함께 설치되어야하는 소프트웨어와 운영체제 패키지가 필요하지 않다. 

flexible 환경에서는 App Engine 환경에서 Docker 컨테이너를 실행한다. flexible 환경은 어플리케이션 코드를 갖고 있지만, 라이브러리나 다른 써드파티 소프트웨어가 필요한 경우 잘 동작한다. 이름에서 알수 있듯이, flexible 환경은 백그라운드 프로세스에서 작업하고 로컬 디스트에 작성하는 기능을 포함한 많은 옵션을 제공한다.

챕터 9는 App Engine 사용과 관리를 위한 상세정보를 소개할 것이다. App Engine을 탐색하기 위해서 구글 Cloud Console에서 왼쪽 메뉴 중, App Engine을 선택한다.

#### Cloud Functions

구글 Cloud Functions는 이벤트 중심 프로세싱에 적합한 가벼운 컴퓨팅 옵션이다. Cloud Functions은 Cloud Storage에 파일이 업로드되거나 메시지 큐에 메시지가 쓰여진것 처럼 이벤트를 응답하는 코드를 실행한다. Cloud Functions 환경에서 실행되는 코드는 짧게 동작해야하고, 이 컴퓨팅 서비스는 오래 동작하는 코드를 실행하도록 설계되지 않았다. 오래 동작하는 어플리케이션이나 업무를 지원해야할 필요가 있다면, Compute Engine, Kubernetes Engine, App Engine을 고려해야한다.

Cloud Functions은 써드파티 API나 자연어 번역 서비스같은 다른 GCP 서비스와 같은 다른 서비스를 호출하는데 자주 사용된다. 

App Engine처럼, Cloud Functions은 서버리스 제품이다. 사용자는 오직 코드를 제공해야한다; VM을 설정하거나 컨테이너를 생성할 필요가 없다. Cloud Functions은 부하 증가에따라서 자동적으로 확장한다.

4가지 주요 컴퓨팅 제품에 추가적으로 GCP는 스토리지 리소스를 제공한다.

챕터 10은 Cloud Functions 사용과 관리의 상세정보를 설명한다. Cloud Functions을 탐색하기위해서 구글 Cloud Console에 로그인하고 왼쪽 메뉴에서 Cloud Functions을 선택한다.

## GCP의 스토리지 컴포넌트

클라우드에서 동작하는 어플리케이션과 서비스는 저장소에 대한 넓은 범위의 요구사항을 충족해야한다.

### 스토리지 리소스

때때로 어플리케이션은 적당한 양의 데이터를 빠르게 읽고 쓰는게 필요하다. 경우에 따라 비즈니스 어플리케이션은 페타바이트의 저장소에 접근할 필요가 있을지도 모른다. 하지만 문서를 조회하는데 몇 분, 심지어 몇 시간까지 허용할 수 있다. GCP는 오브젝트와 파일을 저장하기위한 스토리지 리소스를 갖고 있다.

#### Cloud Storage

Cloud Storage는 GCP의 오브젝트 스토리지 시스템이다. 오브젝트는 파일이나 바이너리 오브젝트의 어떠한 유형일 수 있다. 오브젝트는 파일 시스템에서 디렉토리와 유사한 버킷에 구성된다. Cloud Storage가 파일 시스템이 아니라는 것을 기억해야한다. 분산된 스토리지 시스템으로터 파일이나 오브젝트를 수신하고, 저장하고, 조회하는 서비스이다. Cloud Storage는 영구 디스크가 추가되는 방식처럼 VM의 일부가 아니다. Cloud Storage는 VM(이나 다른 네트워크 장치)과 영구 디스크에 있는 완전한 파일 시스템에서 접근할 수 있다.

각 저장된 오브젝트는 URL에 의해서 유니크한 주소를 갖고 있다. 예를 들어, *ace-certification-exam-prep* 이름의 버킷에 저장된 이 챕터의 .pdf 버전인 chapter1.pdf는 아래와 같은 주소로 지정될 수 있다.
**https://storage.cloud.google.com/ace-certification-exam-prep/chapter1.pdf**

GCP 사용자와 다른 사람들은 버킷에 있는 오브젝트를 읽고 쓰는 권한을 얻을 수 있다. 종종, 어플리케이션은 버킷을 읽고 쓸 수 있는 권한을 IAM 정책을 통해서 얻게될 것이다.

Cloud Storage는 단일 데이터를 다루는 오브젝트를 저장하는데 유용하다. 예를 들어, 이미지는 오브젝트 스트리지를 위해 좋은 후보이다. 이미지는 일반적으로 갑작스럽게 읽고 쓰여진다. 드물게 이미지의 한 부분만 조회할 필요가 있다. 일반적으로, 갑작스럽게 오브젝트를 쓰거나 조회하고, 언제 동작할지 모르는 서버의 독립적으로 저장해야 한다면, Cloud Storage는 좋은 옵션이다.

[맨 위로](#Contents) 
