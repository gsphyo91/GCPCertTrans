# Chapter 1 구글 클라우드 플랫폼 Overview

**이 챕터는 Google Associate Cloud Engineer 인증 시험에서 아래 과목을 다룬다.**

* 1.0 클라우드 솔루션 환경 세팅

구글클라우드 플랫폼(GCP)은 구글이 소유하고 있는 제품에서 사용되는 기술의 일부를 제공하는 퍼블릭 클라우드 서비스이다. 이 챕터에서는 GCP의 가장 중요한 컴포넌트에 대해 설명하고, 온프레미스 데이터센터 기반의 컴퓨팅과 어떻게 다른지 논한다.

## 클라우드 서비스의 유형

구글, 아마존, 마이크로소프트와 같은 퍼블릭 클라우드 제공업체는 비즈니스 서비스와 어플리케이션의 넓은 범위에서 실행되는 컴퓨팅, 스토리지, 네트워킹, 다른 인프라스트럭쳐를 배포하기위한 서비스를 제공한다. 몇몇 클라우드 사용자는 클라우드에서 시작하는 신생 업체이다. 그들은 보유하고있는 하드웨어와 소프트웨어가 없다. 다른 클라우드 고객은 다수의 데이터센터를 보유하고있는 기업이고, 그들의 데이터 센터를 보완하기위해 퍼블릭 클라우드를 사용한다. 이 다른 종류의 사용자는 다른 요구사항을 갖고 있다.

클라우드에서 시작하는 업체는 보유하고 있는 인프라에 대한 고려없이 그들의 어플리케이션와 구조적 니즈에 가장 알맞는 서비스를 선택할 수 있다. 예를 들면, 스타트업은 모든 인증과 권한 부여에 대한 니즈를 위해 GCP의 IAM(Identity and Access Management) 서비스를 사용할 수 있다. ID 관리를 위해 마이크로소프트 Active Directory 솔루션에 이미 투자한 업체는 클라우드의 ID 관리 시스템과 단독으로 작업하는 대신 클라우드 시스템을 활용할 수도 있다. 이것은 두 시스템을 통합하고 동기화를 유기하기위한 추가적인 작업으로 이끌 수 있다.

인프라를 보유하고 있는 기업들을 위해 고려해야하는 다른 영역은 온프레미스 리소스와 퍼블릭 클라우드 리소스간 보안 네트워크를 구축과 유지하는 것이다. 온프레미스 시스템과 퍼블릭 클라우드간에 높은 볼륨의 네트워크 트래픽이 있다면, 기업에서는 데이터센터와 퍼블릭 클라우드 제공업체의 시설간 전용 네트워크를 투자할 필요가 있다. 트래픽의 양이 시설들 간 전용 연결 비용에 비해 충분하지 않다면, 업체는 공인 인터넷 위에서 동작하는 virtual private network를 사용할 수 있다. 이것은 클라우드만 사용하는 업체에게는 할 필요가 없는 추가적인 네트워크 설계와 관리가 필요하다.

퍼블릭 클라우드 제공 업체는 4가지 넓은 카테고리의 서비스를 제공한다.
* 컴퓨트 리소스
* 스토리지
* 네트워킹
* 머신러닝 서비스와 같은 특별한 서비스들

클라우드 고객들은 전형적으로 위 카테고리중 하나 이상의 서비스를 사용한다.

### Compute Resources

컴퓨팅 리소스는 퍼블릭 클라우드에서 다양한 형태로 존재한다.

#### 가상머신

가상머신은 컴퓨팅 리소스의 기본적인 단위이고 클라우드를 경험하는데 가장 좋은 시작 포인트이다. 클라우드 제공업체에 계정을 생성하고 빌링 정보를 제공한 후에, VM을 생성하는 포털이나 커맨드라인 도구를 사용할 수 있다. 구글 클라우드 플랫폼은 다양한 수의 vCPU와 다양한 메모리가 미리 지정된 다양한 VM을 제공한다. 그리고 미리 지정된 VM이 필요하지 않는다면 커스텀으로 설정해서 생성할 수 있다.

VM을 생성하면, 로그인하여서 원하는대로 관리할 수 있다. VM에 완전한 접근권한을 갖고 있어서 파일 시스템을 설정하고, 스토리지를 설정하고, OS를 설치하고, 추가적인 패키지를 설치할 수 있다. VM에서 무엇을 실행할 지, 누구를 접속하게 할 지, 언제 VM을 종료할 것인지 결정할 수 있다. 본인이 관리하는 VM은 관리자 권한을 갖는 서버를 본인의 사무일에 둔 것과 같다. 

물론 다른 운영체제와 어플리케이션을 실행하는 다수의 VM을 생성할 수 있다. 또한 GCP는 하나의 접근 포인트를 백엔드로 분산하는 로드밸런서와 같은 서비스를 제공한다. 이것은 특히 당신의 어플리케이션을 위해 HA(high availability)가 필요할 때 유용하다. 클러스터에서 VM 중 하나에 에러가 발생하면, 워크로드는 클러스터의 다른 VM으로 분산될 수 있다. 오토스케일러는 워크로드를 기반으로 클러스터의 VM을 추가하거나 제거할 수 있다. 이것을 오토 스케일링이라고 한다. 이것은 필요보다 많은 VM이 동작하지 않기 위해 비용을 제어하고, 워크로드가 증가할 때 충분한 컴퓨팅 용량을 사용할 수 있도록 도와준다.

#### 관리형 Kubernetes 클러스터

구글 클라우드 플랫폼은 서버의 클러스터를 생성하고 관리하는데 필요한 모든 도구를 제공한다. 많은 클라우드 사용자는 그들의 어플리케이션에 초점을 두고있고, 서버가 기동하고 동작하는 클러스터를 유지하는데 필요한 작업을 하지 않는다. 이 사용자들에게 관리형 클러스터는 좋은 옵션이다.

관리형 클러스터는 컨테이너를 활용한다. 컨테이너는 같은 서버에서 하나의 컨테이너에서 동작하는 프로세스가 다른 컨테이너에서 동작하는 프로세스로부터 독립되는 가벼운 VM과 같다. 관리형 클러스터에서 실행하기 원하는 서버의 수와 여기서 동작해야하는 컨테이너를 지정할 수 있다. 또한, 동작하는 컨테이너의 수에 최적화된 오토스케일링 파라미터를 지정할 수 있다.

관리형 클러스터에서 컨테이너의 상태를 모니터링한다. 컨테이너가 에러로 인해 종료되면 클러스터 관리 소프트웨어는 이를 감지하고 다른 컨테이너를 실행한다.

컨테이너는 당신의 환경에서 다수의 마이크로 서비스가 요구되는 어플리케이션을 실행할 때 좋은 옵션이다. 서비스는 컨테이너를 통해 배포되고, 클러스터 관리 서비스는 모니터링, 네트워킹, 몇몇 보안 관리 업무를 다룬다. 

#### 서버리스 컴퓨팅

VM과 관리형 Kubernetes 클러스터는 모두 컴퓨팅 리소스를 설정하고 관리하기 위한 노력이 필요하다. 서버리스 컴퓨팅은 개발자와 어플리케이션 관리자에게 VM이나 Kubernetes 클러스터를 세팅할 필요없이 컴퓨팅 환경에서 그들의 코드를 동작하는 것을 허용한다는 접근이다. 

구글 클라우드 플랫폼에선 2가지 서버리스 컴퓨팅 옵션이 있다. App Engine과 Cloud Functions. App Engine은 웹사이트 백엔드, POS 시스템, 고객 비즈니스 어플리케이션과 같이 장시간동안 실행되는 어플리케이션과 컨테이너를 위해 사용된다. Cloud Functions은 파일 업로딩이나 메시지 큐에 메시지가 추가되는 것과 같은 이벤트를 응답하기위한 코드를 실행하는 플랫폼이다. 이 서버리스 옵션은 함수로 짜여진 짧은 프로세스를 실행하거나 VM, 클러스터, App Engine에서 장시간 실행되는 어플리케이션을 호출하여 이벤트를 응답해야 할 때 잘 동작한다.

### 스토리지

퍼블릭 클라우드는 넓은 범위의 어플리케이션 요구사항에 유용한 몇몇 유형의 스토리지 서비스를 제공한다.
* Object storage
* File storage
* Block storage
* Caches

클라우드 서비스의 기업 고객은 이런 서비스들의 조합을 자주 사용할 것이다.

#### Object Storage

오브젝트 스토리지는 오브젝트나 블롭(blobs) 단위의 스토리지 사용을 관리하는 시스템이다. 보통 오브젝트는 파일이지만, 기존 파일 시스템에서 저장되지 않는다. 오브젝트는 버킷에 그룹화된다. 각 오브젝트는 개별로 주소가 지정될 수 있고, 보통 URL로 지정된다.

오브젝트 스토리지는 서버의 디스크나 SSD 사이즈에 의해 제한되지 않는다. 오브젝트는 디스크의 사용 용량에 대한 걱정없이 업로드할 수 있다. 가용성과 내구성을 향상시키기 위해서 다수의 오브젝트 복사본이 저장된다. 몇몇 케이스에서 오브젝트의 복사본은 가용성을 보장하기 위해서 다른 regions에 저장될 수도 있다.

오브젝트 스토리지의 다른 장점은 서버리스다. 스토리지를 위해서 VM이 필요하지 않다. Cloud Storage라고 불리는 GCP의 오브젝트 스토리지는 GCP에서 동작하는 서버뿐만 아니라 인터넷에 접속한 다른 디바이스에서 접근할 수 있다.

접근 제어는 오브젝트 단위로 적용할 수 있다. Cloud storage 사용자에게 오브젝트에 접근하고 업데이트할 수 있도록 허용한다.

#### File Storage

파일 스토리지는 파일을 위한 계층구조의 스토리지 시스템이다. 파일 시스템 스토리지는 네트워크 공유 파일 시스템을 제공한다. GCP는 Cloud Filestore라고 불리는 네트워크파일시스템(NFS)기반의 파일 스토리지 서비스를 갖고있다. 

파일 스토리지는 파일 엑세스 같은 OS가 필요한 어플리케이션에 적합하다. 파일 스토리지 시스템은 파일 시스템을 특정 VM에서 분리한다. 파일시스템, 디렉토리, 파일은 해당 파일에 접근할 수 있는 VM이나 어플리케이션과 독립적으로 존재한다.

#### Block Storage

블록 스토리지는 `block` 이라고 불리는 고정된 크기의 데이터 구조를 사용하여 데이터를 구성한다. 블록 스토리지는 일반적으로 VM에 연결된 임시 및 영구 디스크에 사용된다. 블록 스토리지 시스템을 사용하면, 블록 스토리지 위에 파일시스템을 설치하거나 블록에 직접 접근하는 어플리케이션을 실행할 수 있다. 

리눅스 파일 시스템에서는 4KB가 일반적인 블록 사이즈이다. 관계형 데이터베이스는 종종 직접 블록을 쓰지만, 8KB 이상의 큰 사이즈를 종종 사용한다. 

블록 스토리지는 GCP에서 VM에 연결된 디스크에서 이용할 수 있다. 블록 스토리지는 임시적이거나 영구적일 수 있다. 영구 디스크(persistent disk)는 가상 서버에서 연결이 끊어지거나 서버가 죽어도 저장된 데이터를 유지한다. 임시 디스크(Ephemeral disk)는 VM이 동작하는 동안 데이터를 저장한다. 임시 디스크는 OS파일과 다른 파일들, VM이 멈추면 삭제되는 데이터를 저장한다. 영구 디스크는 VM과 독립적인 블록 스토리지 장치에 저장하기를 원할 때 사용된다. 이러한 디스크는 VM 라이프사이클과 독립적으로 사용하고, OS 및 파일시스템 레벨의 빠르게 접근하기를 원하는 데이터를 가질 때 좋은 옵션이다.

오브젝트 스토리지는 VM 라이프사이클과 독립적으로 데이터를 저장하지만, OS나 파일시스템을 지원하지 않는다.(오브젝트에 접근하는 HTTP와 같은 하이레벨 프로토콜을 사용해야한다.) 오브젝트 스토리지의 데이터를 조회하는 것은 블록 스토리지의 데이터를 조회하는것보다 오래걸린다. 어플리케이션의 필요에따라 오브젝트 스토리지와 블록 스토리지의 결합이 필요할 수 있다. 오브젝트 스토리지는 필요할 때 영구 디스크에 복사된 대용량의 데이터를 저장할 수 있다. 이 결합은 필요할 때 OS와 파일시스템 접근과 함께 대용량 스토리지의 이점을 제공한다.

#### Caches

캐쉬는 데이터를 빠르게 접근하는 인메모리 데이터 저장소이다. 데이터를 조회하는 데 걸리는 시간은 `latency`라고 부른다. 인메모리 저장소의 latency는 1 밀리초 미만으로 설계되었다. 비교를 위해서 아래 latency 참고:
* 기본 메모리 참조를 만드느데 100나노초 혹은 0.1마이크로초
* SSD의 4KB 임의 데이터를 읽는 것은 150 마이크로초
* 메모리의 1MB 데이터를 순차적으로 읽는 것은 250 마이크로초
* SSD의 1MB 데이터를 순차적으로 읽는 것은 1,000 마이크로초 혹은 1 밀리초
* 디스크의 1MB 데이터를 순차적으로 읽는 것은 20,000 마이크로초 혹은 20 밀리초

단위 변환을 위한 참조:
* 1,000 나노초 = 1 마이크로초
* 1,000 마이크로초 = 1 밀리초
* 1,000 밀리초 = 1 초

유용한 데이터 타이밍은 Jonas Boner의 "Latency Numbers Every Programmer Should Know"에서 확인할 수 있다. [https://gist.github.com/jboner/2841832](https://gist.github.com/jboner/2841832)

1MB 데이터를 읽는 예로 보자. 인메모리로 캐쉬에 저장된 데이터를 갖고있다면, 이 데이터를 조회하는데 250 마이크로초 혹은 0.25 밀리초가 걸린다. 같은 데이터가 SSD에 저장되면, 조회하는데 시간이 1밀리초로 4배가 걸린다. 같은 데이터가 하드디스크에 저장되면, 20 밀리초가 예측되고 이는 인메모리 캐쉬보다 80배이다.

캐쉬는 어플리케이션에서 최소한의 지연으로 데이터를 읽을 필요가 있을 때 꽤 유용하다. 물론, 빠른 조회 시간을 누가 안 좋아하나? 왜 항상 데이터를 캐쉬에 저장하지 않을까? 3가지 이유가 있다.
* 메모리는 SSD나 HDD 스토리지보다 비싸다. 대부분의 경우 SSD 또는 HDD의 영구 블록 스토리지만큼 인메모리 스토리지를 보유하는 것은 실용적이지 않다.
* 캐쉬는 휘발성이다. 전원이 끊어지거나 OS가 재부팅될 때 캐쉬에 저장된 데이터를 잃는다. 빠른 접근을 위해서 캐쉬에 데이터를 저장할 수 있지만, 데이터를 유지하는 유일한 저장소로 사용되어서는 안 된다. "진정한 시스템" 혹은 항상 최신, 가장 정확한 버전의 데이터를 저장한 데이터 저장소를 유지하기 위해서는 어떠한 형태의 영구 디스크를 사용해야 한다.
* 캐쉬는 실제 시스템과 동기화되지 않을 수 있다. 실제 시스템에 업로드 되었지만, 새로운 데이터가 캐쉬에 쓰여지지 않는 경우가 생길 수 있다. 이 현상이 발생했을 때, 캐쉬에 의존하는 어플리케이션에서는 캐쉬에 있는 데이터가 적절하지 않다는 사실을 감지하는 것은 어려울 수 있다. 캐쉬를 사용하기로 결정을 했다면 캐쉬와 실제 시스템간 지속성을 위한 요구사항을 충족하는 캐쉬 업데이트 전략을 설계해야 한다. 이 것은 Phil Karlton의 잘 알려진 명언인 "There are only two hard thins in computer science: cache invalidation and naming thins." ([https://martinfowler.com/bliki/TwoHardThings.html](https://martinfowler.com/bliki/TwoHardThings.html))처럼 어려운 설계 문제이다.

> **실제 시나리오** <br>
> 데이터베이스 쿼리 응답시간 개선하기
>> 사용자는 빠르게 응답하는 웹 어플리케이션을 기대합니다. 페이지가 로드하는데 2~3초이상 소요된다면, UX는 고통일 수 있다. 고객 ID에 계정 정보를 찾는 것과 같이 데이터베이스 쿼리의 결과를 사용하는 페이지의 컨텐츠를 생성하는 데 일반적이다. 데이터베이스를 쿼리할 때, 데이터베이스 엔진은 보통 디스크에서 데이터를 찾을 것이다. 많은 유저가 데이베이스로 쿼리를 할수록 많은 쿼리가 발생한다. 데이터베이스는 응답이 필요하지만, 다른 쿼리로 인해 바쁘기 때문에 처리하지 못하는 쿼리에 대한 큐를 갖고 있다. 이 것은 웹 어플리케이션이 쿼리의 결과가 리턴되기를 기다려야하기 때문에, 응답 시간이 지연되는 원인일 수 있다.
>> 
>> 지연시간을 줄기는 한 가지 방법은 데이터를 읽는데 필요한 시간을 줄이는 것이다. 몇몇 경우에서, 하드디스크를 더 빠른 SSD로 대체하는 것이 도움이 된다. 그러나 쿼리의 양이 SSD에서도 큐에서 오래 걸린다면, 캐쉬를 사용하는 것이 또 다른 옵션이다.
>> 
>> 쿼리 결과를 가져올 때, 캐쉬에 저장된다. 정보가 필요할 때, 데이터베이스 대진 캐쉬에서 가져온다. 이 것은 데이터를 디스크보다 빠르게 메모리에서 가져오기 때문에 시간을 줄일 수 있다. 또한 데이터베이스 쿼리의 양을 줄이므로 캐쉬에서 데이터를 조회할 수 없는 쿼리는 처리되기 전에 쿼리 큐에서 오래 기다릴 필요가 없다.

### 네트워킹

클라우드에서 동작할 때, 클라우드 리소스와 온프레미스 시스템간 네트워킹을 작업할 필요가 있을 것이다.

클라우드 환경에서 동작하는 다수의 VM을 갖고 있을 때, 몇몇 포인트의 IP 주소를 관리할 필요가 있을 것이다. 사용자 환경에서 각 네트워크 접근 장치나 서비스는 IP주소가 필요할 것이다. 사실, GCP 내 장치는 내부와 외부 주소를 갖을 수 있다. 내부 주소는 오직 GCP 내부 네트워크에서 서비스를 접속할 수 있다. GCP 내부 네트워크는 Virtual Private Cloud(VPC)로 정의된다. 외부 주소는 인터넷을 통해서 접속할 수 있다.

외부 IP 주소는 정적 주소나 임시 주소가 될 수 있다. 정적 주소는 장시간동안 장치에 할당된다. 임시 외부 IP주소는 VM에 붙여지고, VM이 멈췄을 때 개방된다. 

IP주소를 지정하는것 외에도, VPC의 서브네트워크와 VM들로 접근을 제어하는 방화벽 정책을 정의할 필요가 있을 것이다. 예를 들어, 오직 어플리케이션 서버만 데이터베이스롤 쿼리할 수 있도록 접근을 제한하려는 데이터베이스 서버가 있을 수 있다. 방화벽 정책은 어플리케이션의 IP주소나 어플리케이션 클러스터의 앞에 있는 로드밸런서로의 인바운드와 아웃바운드 트랙픽을 제한하도록 설정할 수 있다. 

온프레미스 데이터 센터와 VPC 간에 데이터와 네트워크 접근을 공유할 필요가 있을 수 있다. 별개의 네트워크를 연결하기 위한 일반적인 용어인 `peering`의 여러 유형중 하나를 사용하여 수행할 수 있다.

### 특별한 서비스

대부분의 퍼블릭 클라우드 제공업체는 어플리케이션의 블록이나 데이터를 처리하기 위한 절차의 한 부분에서 사용될 수 있는 특별한 서비스를 제공한다.

특별한 서비스의 공통적인 특성은 아래와 같다.
* 서버리스이다.; 서버나 클러스터를 구성할 필요가 없다.
* 텍스트를 번역하거나 이미지를 분석하는 특정 함수를 제공한다.
* 서비스의 기능을 접근하는 API(Application Programming Interface)를 제공한다.
* 다른 클라우드 서비스와 마찬가지로 서비스에서 사용하는 만큼 비용이 청구된다.

GCP의 특별한 서비스 중 일부는 아래와 같다.
* 머신러닝 서비스, AutoML
* 텍스트를 분석하기위한 서비스인 Cloud Natural Language
* 이미지 분석을 위한 Cloud Vision
* 시간 단위 데이터에 대한 상관관계를 계산하는 서비스인 Cloud Interface API

특별한 서비스는 고급 컴퓨팅 기능을 캡슐화하여 자연언어 처리와 머신러닝과 같은 도메인을 전문가가 아닌 개발자가 접근할 수 있도록 한다. GCP에 더 많은 특별한 서비스가 추가될 것으로 예상된다.

## 클라우드 컴퓨팅 vs 데이터센터 컴퓨팅

클라우드에서 동작하는 VM이 데이터센터에서 동작하는 VM과 차이가 없어보여도, 클라우드에서 운영하는 IT환경과 온프레미스나 데이터센터간에 상당한 차이가 있다.

### 리소스 소유 대신 대여

기업의 데이터 센터는 서버, 디스크, 네트워크 장치로 가득 차있다. 이 장치는 회사에 소유되거나 장기간동안 임대되고, 이 모델은 장치를 구매하거나 장기간 임대하기 위해서 상당한 양의 돈을 회사에서 소비한다. 이 방법은 기업에서 장기간 필요한 서버와 다른 장치의 양을 정확하게 예측하고, 지속적으로 활용할 수 있을 때 적합하다.

이 모델은 기업이 평균 워크로드보다 상당히 높은 용량을 계획해야할 때 제대로 동작하지 않는다. 예를 들어, 유통업체가 20개 서버의 클러스터가 필요한 평균 로드를 받고 있지만, 연휴기간동은 워크로드는 80개의 서버가 필요한 포인트까지 증가한다. 회사는 80개의 서버를 구매하고, 60개의 서버를 1년의 대부분을 Idle 상태로 두어 최대 용량을 수용할 수 있는 자원으로 확보한다. 그 대신에 더 적은 서버를 구매하거나 임대할 수 있고, 컴퓨트 리소스가 수요를 견딜 수 없을 때 일어나는 기업의 손실을 발생한다. 둘 다 매력적인 옵션을 아니다.

퍼블릭 클라우드는 컴퓨트 용량의 단기간 대여의 대안을 제공한다. 예를 들어, 유통업체가 피크 기간동안 온프레미스 서버 이외에도 클라우드에서 VM을 동작했다. 이 것은 유통업체는 필요하지 않을 때 비용 지불을 하지 않고, 필요할 때 서버에 접근할 수 있따.

클라우드에서 동작 중인 서버의 단위 비용은 데이터 센터에서 동작 중인 동등한 서버보다 높을 수도 있다. 하지만, 온 프레미스의 전체 비용과 클라우드에서 단기간 서버의 조합은 최대 용량을 위한 구매나 임대하는 것과 리소스를 유휴상태로 유지하는 비용보다 상당히 적을 수 있다.

### 종량제 모델

클라우드 컴퓨팅의 단기간 임대 모델와 관련있는 것은 종량제 모델이다. 클라우드에서 가상 서버를 동작할 때, 전형적으로 10분과 같이 최소 기간동안과 이 후에 사용된 시간만큼 비용을 지불할 것이다. 분당 단위 비용은 서버의 특성에 따라 다르다. 많은 CPU와 메모리를 갖는 서버는 적은 CPU와 메모리를 갖는 서버보다 많은 비용이 발생한다.

클라우드 엔지니어는 클라우드 제공업체의 비용 모델을 이해하는 것이 중요하다. 사용내역에 대해서 모니터링하지 않는다면 서버와 스토리지에 대해 많은 비용청구서를 받기 쉽다. 사실, 몇몇 클라우드 사용자들은 클라우드에서 동작하는 어플리케이션이 온프레미스에서 동작하는 것보다 더 비쌀수 있다는 것을 알고 있다.

### 탄력적인 리소스 할당

온프레미스와 퍼블릭 클라우드 컴퓨팅 간 또 다른 차별화 키는 짧은 알림으로 컴퓨트와 스토리지 자원을 추가하고 제거할 수 있는 능력이다. 클라우드에서 몇분만에 20개의 서버를 동작할 수 있다. 온프레미스 데이터센터에서는 몇 일이 걸리거나 추가적인 하드웨어를 할당받는다면 몇주가 걸릴 수 있다. 

클라우드 제공업체는 광범위한 컴퓨트, 스토리지, 네트워크 리소스를 갖는 데이터센터를 설계한다. 제공업체는 고객들에게 효과적인 리소스 효과적으로 임대하여 투자를 최적화한다. 고객 사용 패턴에 대한 충분한 데이터로 고객의 요구를 충족시키기 필요한 용량을 예측할 수 있다. 제공업체는 많은 고객을 가지고 있기 때문에, 한 고객의 수요 변화는 리소스의 전체적인 사용에 거의 영향을 미치지 않는다.

광범위한 리소스와 고객간에 따르게 리소스를 이동시키는 능력을 통해 퍼블릭 클라우드 제공업체는 작은 데이터센터에서 할 수 있는 것보다 더 효과적으로 탄력적인 리소스 할당을 제공할 수 있다.

### 특별한 서비스

특별한 서비스는 널리 알려지지 않았다. 많은 개발자들은 UI를 개발하거나 데이터베이스를 쿼라히는 방법에 대해 이해하지만, 자연어 처리나 머신러닝의 상세 정보를 이해하는 사람은 거의 없다. 큰 기업은 데이터 사이언스와 머신 비전과 같은 영역에서 전문가들이 사내에서 개발할 수 있는 제정적인 자원을 가질 수도 있지만, 대부분의 다른 기업은 아니다.

특별한 서비스를 제공함으로써, 클라우드 제공업체는 더 많은 개발자들에게 고급 기능을 제공하고 있다. 많은 양의 하드웨어에 투자하는것 처럼 퍼블릭 클라우드 업체는 특별한 서비스에 투자하고, 많은 고객들에 의해서 사용되기 때문에 수익을 벌고, 비용을 회복할 수 있다.

## 시험 필수요소

**클라우드 컴퓨팅 리소스를 제공하는 다양한 방법을 이해한다.** 컴퓨팅 리소스는 개별적인 VM이나 VM 클러스터로 할당될 수 있다. 또한 Kubernetes 클러스터를 관리하는 운영적인 일부 오버헤드를 완화하는 관리형 Kubernetes 클러스터(GKE)를 사용할 수 있다. 서버리스 컴퓨팅 옵션은 사용자의 서버관리 부담을 줄여준다. 그 대신 개발자들은 클라우드 제공업체에 의해서 관리되는 컨테이너 환경이나 짧은 실행 코드를 위해 설계된 컴퓨트 플랫폼에서 그들의 코드를 실행한다. 개발자들과 DevOps 전문가들은 그들이 소요한 서버와 클러스터를 관리할 때 리소스에 대해 가장 많이 제어한다. 관리형 서비스와 서버리스 옵션은 컴퓨팅 환경에 대한 제어가 필요하지 않고, 컴퓨트 리소스를 관리하지않고 많은 가치를 얻을 때 좋은 선택이다.

**클라우드 스토리지의 다양한 형태와 사용 시기를 이해한다.** 스토리지의 4가지 분류가 있다: 오브젝트, 파일, 블록, 인메모리 캐쉬. 오브젝트 스토리지는 이미지나 데이터 셋과 같은 오브젝트 저장에 높은 신뢰성과 내구성을 위해 설계되었다. 오브젝트 스토리지는 스토리지 시스템 기반의 파일시스템보다 기능적으로 더 제한된다. 스토리지 기반의 파일 시스템은 파일을 위한 계층구조의 디렉토리 스토리지를 제공하고, 공통적인 OS와 파일 시스템 기능을 지원한다. 파일시스템 서비스는 많은 서버에 의해서 접근될 수 있는 네트워크 접근이 가능한 파일시스템을 제공한다. 블록 스토리지는 디스크에 데이터를 저장하기위해 사용된다. 파일시스템과 데이터베이스는 블록 스토리지 시스템을 사용한다. 블록 스토리지는 SSD와 HDD와 같은 영구 스토리지 장치와 사용된다. 캐쉬는 데이터 조회의 지연을 최소화하기 위해 사용되는 인메모리 데이터 저장소이다. 이는 영구 스토리지를 제공하지 않고, "진실의 시스템"으로 간주되어서는 안 된다.

**온프레미스나 클라우드에서 동작하는 IT환경 간 차이점을 이해한다.** 클라우드에서 동작하는 IT 환경은 단기간 리소스 대여, 종량제 모델, 탄력적인 리소스 할당, 특별한 서비스 사용 능력을 포함한 몇몇 장점을 갖고있다. 미들웨어 서버의 분당 비용과 같은 클라우드 리소스의 단위 비용은 온프레미스보다 클라우드가 더 높을 수도 있다. 클라우드와 온프레미스 리소스간 워크로드의 가장 효과적인 분산에 대해서 결정하기 위해 클라우드 제공업체의 비용 모델을 이해하는 것이 중요하다.

[맨 위로](#chapter-1-%ea%b5%ac%ea%b8%80-%ed%81%b4%eb%9d%bc%ec%9a%b0%eb%93%9c-%ed%94%8c%eb%9e%ab%ed%8f%bc-overview)